package lab3;

import Test;
import lejos.hardware.motor.EV3LargeRegulatedMotor;

public class Navigator {

	private static final int FORWARD_SPEED = 250;
	private static final int ROTATE_SPEED = 150;
	EV3LargeRegulatedMotor leftMotor;
	EV3LargeRegulatedMotor rightMotor;
	double leftRadius; 
	double rightRadius; 
	double width; 
	boolean navigate;
	public static boolean wallDetected;
	Odometer o;
	UltrasonicPoller usPoller;
	
	public Navigator(EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor,
			double leftRadius, double rightRadius, double width, boolean navigate, Odometer o, UltrasonicPoller usPoller)
			{
				this.leftMotor = leftMotor;
				this.rightMotor = rightMotor;
				this.leftRadius = leftRadius;
				this.rightRadius = rightRadius;
				this.width = width;
				this.navigate = navigate;
				this.o = o;
				this.usPoller = usPoller;
				Navigator.wallDetected = false;
			}
	
	public void drive() {
		// reset the motors
		for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] { this.leftMotor, this.rightMotor }) {
			motor.stop();
			motor.setAcceleration(1000);
		}

		// wait 5 seconds
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// there is nothing to be done here because it is not expected that
			// the odometer will be interrupted by another thread
		}

		if(navigate == true)
		{
			NavThread thread1 = new NavThread(true);
			NavThread thread2 = new NavThread(false);
			
			thread1.start();
			thread2.start();
		}
		else
		{
			// Turn from (0,0) to (60,30)
			double theta = calcTurn(0,0,60,30);
			turnTo(theta);
			//Drive from (0,0) to (60,30)
			travelTo(60,30);
			
			// Turn from (60,30) to (30,30)
			theta = calcTurn(60,30,30,30);
			turnTo(theta);		
			//Drive from (60,30) to (30,30)
			travelTo(30,30);
			
			// Turn from (30,30) to (30,60)
			theta = calcTurn(30,30,30,60);
			turnTo(theta);		
			//Drive from (30,30) to (30,60)
			travelTo(30,60);
						
			// Turn from (30,60) to (60,0)
			theta = calcTurn(30,60 ,60,0);
			turnTo(theta);					
			//Drive from (30,60) to (60,0)
			travelTo(60,0);
		}
	}
	
	public void travelTo(double x, double y)
	{
		double xi = this.o.getX();
		double yi = this.o.getY();
		double dist = Math.sqrt(Math.pow(x-xi,2)+Math.pow(y-yi,2));
		this.leftMotor.setSpeed(FORWARD_SPEED);
		this.rightMotor.setSpeed(FORWARD_SPEED);
		this.leftMotor.rotate(convertDistance(leftRadius, dist), true);
		this.rightMotor.rotate(convertDistance(rightRadius, dist), false);
	}
	
	public void turnTo(double theta)
	{
		this.leftMotor.setSpeed(ROTATE_SPEED);
		this.rightMotor.setSpeed(ROTATE_SPEED);
		theta=theta*180/Math.PI;
		leftMotor.rotate(convertAngle(leftRadius, width, theta), true);
		rightMotor.rotate(-convertAngle(rightRadius, width, theta), false);
		
		
	}
	
	public boolean isNavigating()
	{
		return true;
	}
	
	
	public double calcTurn(double xi, double yi, double xf, double yf)
	{
		double diffX = xf-xi;
		double diffY = yf-yi;
		double theta = 0;
		double curTheta = this.o.getTheta();
		double axisTheta = 0;
		
		
		if(diffX > 0 && diffY > 0)			// Traveling to positive x and y
		{
			theta = Math.atan2(diffY,diffX);
			axisTheta = Math.PI/2-theta;
			
			double theta1 = 2*Math.PI-curTheta+axisTheta;
			double theta2 = curTheta-axisTheta;
				
			if(Math.abs(theta1)<Math.abs(theta2))
			{
				theta = theta1;
			}
			else
			{
				theta = -theta2;
			}		
		}
		else if(diffX > 0 && diffY < 0)			// Traveling to negative y and positive x
		{
			theta = Math.atan2(diffY,diffX);
			axisTheta = Math.PI/2-theta;
			
			double theta1 = 2*Math.PI-curTheta+axisTheta;
			double theta2 = curTheta-axisTheta;
			
			if(Math.abs(theta1)<Math.abs(theta2))
			{
				theta = theta1;
			}
			else
			{
				theta = -theta2;
			}
		}
		
		else if(diffX < 0 && diffY < 0)
		{
			theta = Math.atan2(diffY,diffX);
			axisTheta = 3*Math.PI/2-theta;
			
			double theta1 = 2*Math.PI-curTheta+axisTheta;
			double theta2 = curTheta-axisTheta;
				
			if(Math.abs(theta1)<Math.abs(theta2))
			{
				theta = theta1;
			}
			else
			{
				theta = -theta2;
			}
			
		}

		else if(diffX < 0 && diffY > 0)
		{
			theta = Math.atan2(diffY,diffX);
			axisTheta = 3*Math.PI/2-theta;
			
			double theta1 = 2*Math.PI-curTheta+axisTheta;
			double theta2 = curTheta-axisTheta;
				
			if(Math.abs(theta1)<Math.abs(theta2))
			{
				theta = theta1;
			}
			else
			{
				theta = -theta2;
			}

		}
		
		else if(diffX == 0)
		{
			if(diffY > 0)
			{
				if(curTheta >= 0 && curTheta <= Math.PI)
				{
					theta = -curTheta;
				}
				else if(curTheta > Math.PI && curTheta <= 2*Math.PI)
				{
					theta = 2*Math.PI-curTheta;
				}

			}
			else if (diffY < 0)
			{
				if(curTheta >= 0 && curTheta <= Math.PI)
				{
					theta = Math.PI-curTheta;
				}
				else if(curTheta > Math.PI && curTheta <= 2*Math.PI)
				{
					theta = -(curTheta-Math.PI);
				}
			}
		} 
		else if(diffY == 0)
		{
			if(diffX > 0)
			{
				if(curTheta >= 0 && curTheta <= Math.PI/2)
				{
					theta = Math.PI/2-curTheta;
				}
				else if(curTheta >= 3*Math.PI/2 && curTheta <= 2*Math.PI)
				{
					theta = 2*Math.PI-curTheta+Math.PI/2;
				}
				else if(curTheta > Math.PI/2 && curTheta < 3*Math.PI/2)
				{
					theta = Math.PI/2-curTheta;
				}

			}
			else if (diffX < 0)
			{
				if(curTheta >= 0 && curTheta <= Math.PI/2)
				{
					theta = -(curTheta+Math.PI/2);
					
				}
				else if(curTheta >= 3*Math.PI/2 && curTheta <= 2*Math.PI)
				{
					theta = -(Math.PI/2-(2*Math.PI-curTheta));
				}
				else if(curTheta > Math.PI/2 && curTheta < 3*Math.PI/2)
				{
					theta = 3*Math.PI/2-curTheta;
				}
			}
		} 
		
		return theta;
	}

	private static int convertDistance(double radius, double distance) {
		return (int) ((180.0 * distance) / (Math.PI * radius));
	}

	private static int convertAngle(double radius, double width, double angle) {
		return convertDistance(radius, Math.PI * width * angle / 360.0);
	}
	
}

class NavThread extends Thread
{
	boolean drive;
	
	public NavThread(boolean drive)
	{
		this.drive = drive;
	}
	
	
   public void run ()
   {
	  
      if(drive)
      {
    	  
      }
      else
      {
    	  
      }
   }
}
